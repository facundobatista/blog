2015-03-12 03:24:58
Metaclasses in Python, the easy way (a real life example)
<tags>



They say that metaclasses make your head explode. They also say that if you're not absolutely sure what are metaclasses, then you don't need them.

And there you go, happily coding through life, jumping and singing in the meadow, until suddenly you get into a dark forest and find the most feared enemy: you realize that some magic needs to be done.


<strong>The necessity</strong>

Why you may need metaclasses? Let's see this specific case, my particular (real life) experience.

It happened that at work I have a script that verifies the <a href="https://developer.ubuntu.com/en/scopes/">remote scopes service</a> for the Ubuntu Phone, checking that all is nice and crispy.

The test itself is simple, I won't put it here because it's not the point, but it's isolated in a method named <span style="font-family: courier new,courier;">_check</span>, that receives the scope name and returns True if all is fine.

So, the first script version did (removed comments and docstrings, for brevity):

<span style="font-family: courier new,courier;">    class SuperTestCase(unittest.TestCase):</span>

<span style="font-family: courier new,courier;">        def test_all_scopes(self):</span>
<span style="font-family: courier new,courier;">            for scope in self._all_scopes:</span>
<span style="font-family: courier new,courier;">                resp = self._check(scope)</span>
<span style="font-family: courier new,courier;">                self.assertTrue(resp)</span>

The problem with this approach is that all the checks are inside the same test. If one check fails, the rest is not executed (because the test is interrupted there, and fails).

Here I found something very interesting, the (new in Python 3) <span style="font-family: courier new,courier;">subTest</span> call:

<span style="font-family: courier new,courier;">    class SuperTestCase(unittest.TestCase):</span>

<span style="font-family: courier new,courier;">        def test_all_scopes(self):</span>
<span style="font-family: courier new,courier;">            for scope in self._all_scopes:</span>
<span style="font-family: courier new,courier;">                with self.subTest(scope=scope):</span>
<span style="font-family: courier new,courier;">                    resp = self._check(scope)</span>
<span style="font-family: courier new,courier;">                    self.assertTrue(resp)</span>

Now, each "sub test" internally is executed independently of the other. So, they all are executed (all checks are done) no matter if one or more fail.

Awesome, right? Well, no.

Why not? Because even if internally everything is handled as independent subtest, from the outside point of view it still is one single test.

This has several consequences. One of those is that the all-inside test takes too long, and you can't know what was going on (note that each of these checks hit the network!), as the test runner just show progress per test (not subtest).

The other inconvenient is that there is not a way to call the script to run only one of those subtests... I can tell it to execute only the all-inside test, but that would mean to execute all the subtests... which, again, takes a lot of time.

So, what I really needed? Something that allows me to express the assertion in one test, but that in reality it were several methods. So, I needed something that, from a single method, reproduce them so the class actually had several ones. This is, write code for a class that Python would find different. This is, metaclasses.


<strong>Metaclasses, but easy</strong>

Luckily, since a couple of years ago (or more), Python provides a simpler way to achieve the same that could be done with metaclasses. This is: <em>class decorators</em>.

Class decorators, very similar to method decorators, receive the class that is defined below itself, and its response is considered by Python the real definition of the class. If you don't have the concept, you may read a little <a href="https://realpython.com/blog/python/primer-on-python-decorators/">here</a> about decorators, and a more deep article about decorators and metaclasses <a href="http://lgiordani.com/blog/2014/10/14/decorators-and-metaclasses/">here</a>, but it's not mandatory.

So, I wrote the following class decorator (explained below):

<span style="font-family: courier new,courier;">    def test_multiplier(klass):</span>
<span style="font-family: courier new,courier;">        """Multiply those multipliable tests."""</span>
<span style="font-family: courier new,courier;">        for meth_name in (x for x in dir(klass) if x.startswith("test_")):</span>
<span style="font-family: courier new,courier;">            meth = getattr(klass, meth_name)</span>
<span style="font-family: courier new,courier;">            argspec = inspect.getfullargspec(meth)</span>

<span style="font-family: courier new,courier;">            # only get those methods that are to be multiplied</span>
<span style="font-family: courier new,courier;">            if len(argspec.args) == 2 and len(argspec.defaults) == 1:</span>
<span style="font-family: courier new,courier;">                param_name = argspec.args[1]</span>
<span style="font-family: courier new,courier;">                mult_values = argspec.defaults[0]</span>

<span style="font-family: courier new,courier;">                # "move" the usefult method to something not automatically executable</span>
<span style="font-family: courier new,courier;">                delattr(klass, meth_name)</span>
<span style="font-family: courier new,courier;">                new_meth_name = "_multiplied_" + meth_name</span>
<span style="font-family: courier new,courier;">                assert not hasattr(klass, new_meth_name)</span>
<span style="font-family: courier new,courier;">                setattr(klass, new_meth_name, meth)</span>
<span style="font-family: courier new,courier;">                new_meth = getattr(klass, new_meth_name)</span>

<span style="font-family: courier new,courier;">                # for each of the given values, create a new method which will call the given method</span>
<span style="font-family: courier new,courier;">                # with only a value at the time</span>
<span style="font-family: courier new,courier;">                for multv in mult_values:</span>
<span style="font-family: courier new,courier;">                    def f(self, multv=multv):</span>
<span style="font-family: courier new,courier;">                        return new_meth(self, **{param_name: multv})</span>

<span style="font-family: courier new,courier;">                    meth_mult_name = meth_name + "_" + multv.replace(" ", "_")[:30]</span>
<span style="font-family: courier new,courier;">                    assert not hasattr(klass, meth_mult_name)</span>
<span style="font-family: courier new,courier;">                    setattr(klass, meth_mult_name, f)</span>

<span style="font-family: courier new,courier;">        return klass</span>

The basics are: it receives a class, it returns a slightly modified class ;). For each of the methods that starts with "test_", I checked those that had two args (not only 'self'), and that the second argument were named.

So, it would actually get the method defined in the following structure and leave the rest alone:

<span style="font-family: courier new,courier;">    @test_multiplier</span>
<span style="font-family: courier new,courier;">    class SuperTestCase(unittest.TestCase):</span>

<span style="font-family: courier new,courier;">        def test_all_scopes(self, scope=_all_scopes):</span>
<span style="font-family: courier new,courier;">            resp = self.checker.hit_search(scope, '')</span>
<span style="font-family: courier new,courier;">            self.assertTrue(resp)</span>

For that kind of method, the decorator will move it to something not named "test_*" (so we can call it but it won't be called by automatic test infrastructure), and then create, for each value in the "_scopes" there, a method (with a particular name which doesn't really matter, but needs to be different and is nice to be informative to the user) that calls the original method, passing "scope" with the particular value.

So, for example, let's say that <span style="font-family: courier new,courier;">_all_scopes</span> is <span style="font-family: courier new,courier;">['foo', 'bar']</span>. Then, the decorator will rename <span style="font-family: courier new,courier;">test_all_scopes</span> to <span style="font-family: courier new,courier;">_multiplied_test_all_scopes</span>, and then create two new methods like this::

<span style="font-family: courier new,courier;">    def test_all_scopes_foo(self, multv='foo'):</span>
<span style="font-family: courier new,courier;">        return self._multiplied_test_all_scopes(scope=multv)</span>

<span style="font-family: courier new,courier;">    def test_all_scopes_foo(self, multv='bar'):</span>
<span style="font-family: courier new,courier;">        return self._multiplied_test_all_scopes(scope=multv)</span>

The final effect is that the test infrastructure (internally and externally) finds those two methods (not the original one), and calls them. Each one individually, informing progress individually, the user being able to execute them individually, etc.

So, at the end, all gain, no loss, and a fun little piece of Python code :) |
